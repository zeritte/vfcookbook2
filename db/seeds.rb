# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)

User.create!(id: 1, name: "Admin", email: "admin@mercedes", role: "admin", password: "salih98")

Domain.create!([
  {id: 1, name: "Security", description: ""},
  {id: 2, name: "Compliance", description: ""},
  {id: 3, name: "Performance", description: ""},
  {id: 4, name: "Maintainability", description: ""},
  {id: 5, name: "Roboutsness", description: ""},
  {id: 6, name: "GRC", description: "Obsolete"},
  {id: 7, name: "Data Loss Prevention", description: ""},
  {id: 8, name: "SLIN", description: ""},
  {id: 9, name: "Naming Convention", description: ""},
  {id: 10, name: "Customer Test Case", description: ""}
])
Impact.create!([
  {id: 1, name: "Info", description: ""},
  {id: 2, name: "Low", description: ""},
  {id: 3, name: "Medium", description: ""},
  {id: 4, name: "High", description: ""},
  {id: 5, name: "Very high", description: ""}
])

Tctype.create!([
  {id: 1, name: "Data Flow Test Cases", description: "From source to sink"}
])
VfCase.create!([
  {id: 3, name: "AUTHORITY-CHECKs With an Incomplete ID List", case_class: "", is_active: true, domain_id: 1, impact_id: 3, tctype_id: 1, documentation: "/VFORGE/CP_TESTCASE_0258", content_en: "<p><strong>Introduction</strong></p><p>This test case identifies usage of AUTHORITY-CHECK commands that do not cover all IDs of the corresponding authorization object.</p><p><strong>Risk</strong></p><p>An occurrence of an incomplete AUTHORITY-CHECK means that an authorization check is required in the business logic, but potentially does not work. Therefore users may perform (critical) actions although access should be restricted. This can result in a compliance violation.</p><p><strong>Details</strong></p><p>The command AUTHORITY-CHECK tests, if the currently logged on user has proper privileges regarding the authorization object passed to this command. Depending on the authorization object, the test can be fine-tuned by passing specific values for the fields specific to this authorization object. Only the fields that are explicitly listed in the check will be tested by the check. If the list is incomplete, the AUTHORITY-CHECK may not be as restrictive as it should be. This test case compares the IDs in the AUTHORITY-CHECK with the IDs of the authorization object and reports all IDs that are not included in the check.</p>", content_de: nil, case_id: "258"},
  {id: 5, name: "SQL Injection (CALL 'C_DB_EXECUTE')", case_class: "", is_active: true, domain_id: 1, impact_id: 5, tctype_id: 1, documentation: "/VFORGE/CP_TESTCASE_0142", content_en: "<p><strong>Introduction</strong></p><p>SQL Injection attacks work by modifying the syntax of a SQL statement via unexpected characters in user input. When a SQL statement contains user input, the SQL query can be modified by an attacker. This way, a malicious user can get read/write access to restricted data.</p><p>In this instance SQL Injections are detected that are caused by the usage of kernel function 'C_DB_EXECUTE'.</p><p><strong>Risk</strong></p><p>When users can manipulate native SQL queries, the following adverse effects arise:</p><ul><li>Confidential / secret business data may be disclosed</li><li>Private data may be disclosed</li><li>Financial data may be modified or deleted</li><li>Fake data may be inserted</li><li>The database structure may be corrupted</li></ul><p>SQL Injections are also almost always compliance violations. Examples are unauthorized access to critical data like credit card numbers, payroll data or medical data.</p><p><strong>Details</strong></p><p>The kernel function 'C_DB_EXECUTE' executes dynamically built native SQL queries in combination with certain opcodes. This enables developers to execute SQL statements that are not available in Open SQL. It also allows developers to dynamically assemble SQL statements at runtime, not at compile time. If user input is part of such a dynamic SQL statement, the statement can actually be altered in a malicious way.</p><p>The ID 'STATTXT' is interpreted as the source of the dynamic SQL statement.</p><p>Be aware that by using dynamic native SQL statements, you can violate compliance.</p>", content_de: nil, case_id: "142"},
  {id: 4, name: "Usage of dangerous Kernel Call ('C_REMOVE')", case_class: "", is_active: true, domain_id: 1, impact_id: 4, tctype_id: 1, documentation: "/VFORGE/CP_TESTCASE_0226", content_en: "\n<p><strong>Introduction</strong></p>\n\n<p>This test case checks if the dangerous kernel function &#39;C_REMOVE&#39; is used.</p>\n\n<p><strong>Risk</strong></p>\n\n<p>As this command allows to delete specific files without authorization, at least the following attacks are possible:</p>\n\n<ul>\n<li>Deletion of forensic evidence in the Security Audit Log</li>\n<li>Deletion of temporary files (specific file path).</li>\n</ul>\n\n<p>These risks jeopardize the integrity of a productive SAP server.</p>\n\n<p><strong>Details</strong></p>\n\n<p>The kernel function C_REMOVE is designed to delete temporary files and files that contain (daily) records of the Security Audit Log. Temporary files can be deleted, if GROUP is set to &#39;TMP&#39;. Security Audit Log files can be deleted, if GROUP is set to &#39;AUDIT&#39;. No authorization check is performed when C_REMOVE is executed. As a result, this kernel function cannot be controlled by authorization objects S_PATH or S_DATASET. Any usage of this command is therefore a bypass of SAP standard protection mechanisms and must be prevented.</p>\n", content_de: nil, case_id: "226"},
  {id: 2, name: "OS Command Execution (Command Name)", case_class: "", is_active: true, domain_id: 1, impact_id: 5, tctype_id: 1, documentation: "/VFORGE/CP_TESTCASE_0247", content_en: "\n<p><strong>Introduction</strong></p>\n\n<p>The ABAP Function Modules SXPG_CALL_SYSTEM and SXPG_COMMAND_EXECUTE can execute operating system commands that are maintained in Transaction SM49 / SM69. If the name of such a command is user input, a malicious user might execute critical commands on the operating system of the SAP server.</p>\n\n<p><strong>Risk</strong></p>\n\n<p>Executing operating system commands may result in the following risks:</p>\n\n<ul>\n<li>Crash of the SAP application server</li>\n<li>Installation of malware</li>\n<li>Creation of privileged user accounts</li>\n<li>Read / Write access to all files of the SAP application server</li>\n</ul>\n\n<p>However, the actual risk depends on the operating system commands that have been maintained in Transaction SM49 / SM69.</p>\n\n<p><strong>Details</strong></p>\n\n<p>In some instances the capabilities of ABAP may not be sufficient to fulfill a given task. For these instances ABAP can call commands/programs on the operating system of an SAP application server. Transactions SM49 and SM69 can be used to maintain a list of allowed operating system commands/programs. Each allowed program is given an alias name, by which ABAP can call it. ABAP can also feed additional parameters to the allowed operating system / command.</p>\n\n<p>Operating system commands are executed by invoking the Function Modules &#39;SXPG_CALL_SYSTEM&#39; and &#39;SXPG_COMMAND_EXECUTE&#39;. Both Function Modules can execute OS commands maintained with Transaction SM49 or SM69 and feed parameters to those commands. In contrast to &#39;SXPG_CALL_SYSTEM&#39;, &#39;SXPG_COMMAND_EXECUTE&#39; can be used to execute commands on an SAP application server other than the one where the calling ABAP code is executed.</p>\n\n<p>This test case determines, if (external) input is used to identify the OS command alias name.</p>\n\n<p>Any usage of these Function Modules should be carefully inspected for security risks.</p>\n\n<p>The probability of a given issue is adjusted in case any prefix or postfix is added to the input.</p>\n\n<p>Static analysis can&#39;t determine if any of the commands configured with SM49 or SM69 actually poses a security risk. Therefore, the finding type is reduced.</p>\n", content_de: nil, case_id: "247"},
  {id: 1, name: "Privileging AUTHORITY-CHECKs (S_TCODE)", case_class: "", is_active: true, domain_id: 1, impact_id: 3, tctype_id: 1, documentation: "/VFORGE/CP_TESTCASE_0280", content_en: "\n<p><strong>Introduction</strong></p>\n\n<p>This test case identifies AUTHORITY-CHECKs on &#39;S_TCODE&#39; that explicitly require &#39;*&#39; authorization for the field &#39;TCD&#39;.</p>\n\n<p><strong>Risk</strong></p>\n\n<p>AUTHORITY-CHECKs enforce the roles and authorizations assigned to SAP users. If an authorization check explicitly requires a &#39;*&#39; authorization in an important field of an authorization object, this forces the roles administrator to assign all legitimate users a &#39;*&#39; authorization in the given field. As a result, these users may be granted privileges that are unnecessarily high and thus might give them increased privileges in other applications, too.</p>\n\n<p><strong>Details</strong></p>\n\n<p>The command AUTHORITY-CHECK tests, if the currently logged on user has proper privileges regarding the authorization object passed to this command. It does so by testing a defined list of fields for the given authorization object. An AUTHORITY-CHECK should always perform a precise check for any given field of the corresponding authorization object. Checking a given field for &#39;*&#39; authorization does NOT mean, that any value in the user&#39;s assigned authorization field is accepted. It means that the user needs the &#39;*&#39; authorization assigned in this field, which grants that user significantly more privileges than necessary.</p>\n\n<p>The field &#39;TCD&#39; in authorization object &#39;S_TCODE&#39; determines for which Transaction a start authorization is to be checked. Forcing a roles administrator to assign &#39;*&#39; in the field &#39;TCD&#39; in authorization object &#39;S_TCODE&#39; is a dangerous elevation of privilege, as it grants access to all SAP Transactions</p>\n", content_de: nil, case_id: "280"}
])
Solution.create!([
  {before_en: "REPORT ZVFORGE_TESTCASE_280.\n\nAUTHORITY-CHECK OBJECT 'S_TCODE'\n   ID 'TCD' FIELD '*' .\nIF sy-subrc = 0.\n  CALL TRANSACTION 'SA38'.\nENDIF.", after_en: "REPORT zvforge_testcase_280_fixed.\n\nCALL FUNCTION 'AUTHORITY_CHECK_TCODE'\n  EXPORTING\n    tcode  = 'SA38'\n  EXCEPTIONS\n    ok     = 0\n    not_ok = 2\n    OTHERS = 3.\nIF sy-subrc = 0.\n  CALL TRANSACTION 'SA38'.\nENDIF.", before_de: nil, after_de: nil, vf_case_id: 1, created_by_id: 1, is_approved: true, footnote_en: "\n<p>Authorization checks on object &#39;S_TCODE&#39; must always specify the Transaction code for which access is to be checked. The recommended way to perform such authorization checks is by calling the Function Module &#39;AUTHORITY_CHECK_TCODE&#39; which performs additional relevant checks. Also, this Function Module does not allow &#39;*&#39; values.</p>\n", footnote_de: nil},
  {before_en: "*Example 1 (SXPG_CALL_SYSTEM)\nDATA REQUEST TYPE REF TO IF_HTTP_REQUEST.\nDATA: CMD       TYPE STRING,\n      LV_STATUS LIKE  EXTCMDEXEX-STATUS,\n      LV_EXIT   LIKE  EXTCMDEXEX-EXITCODE.\n\nCMD  = REQUEST->GET_FORM_FIELD( 'user_input' ).\n\nCALL FUNCTION 'SXPG_CALL_SYSTEM'\n  EXPORTING\n    COMMANDNAME                = CMD\n    ADDITIONAL_PARAMETERS      = ''\n  IMPORTING\n    STATUS                     = LV_STATUS\n    EXITCODE                   = LV_EXIT\n  EXCEPTIONS\n    NO_PERMISSION              = 0\n    COMMAND_NOT_FOUND          = 1\n    PARAMETERS_TOO_LONG        = 2\n    SECURITY_RISK              = 3\n    WRONG_CHECK_CALL_INTERFACE = 4\n    PROGRAM_START_ERROR        = 5\n    PROGRAM_TERMINATION_ERROR  = 6\n    X_ERROR                    = 7\n    PARAMETER_EXPECTED         = 8\n    TOO_MANY_PARAMETERS        = 9\n    ILLEGAL_COMMAND            = 10\n    OTHERS                     = 11. \n    \n    \n    \n*Example 2 (SXPG_COMMAND_EXECUTE)\nDATA request TYPE REF TO if_http_request.\nDATA: CMD       TYPE STRING,\n      LV_STATUS LIKE  EXTCMDEXEX-STATUS,\n      LV_EXIT   LIKE  EXTCMDEXEX-EXITCODE.\ncmd  = request->get_form_field( 'user_input' ).\nCALL FUNCTION 'SXPG_COMMAND_EXECUTE'\nEXPORTING\n   commandname       =  cmd\n   additional_parameters   = ''\nIMPORTING\n   status      = lv_status\n   exitcode       = lv_exit\nEXCEPTIONS\n   no_permission     = 0\n   command_not_found    = 1\n   parameters_too_long     = 2\n   security_risk     = 3\n   wrong_check_call_interface = 4\n   program_start_error     = 5\n   program_termination_error  = 6\n   x_error        = 7\n   parameter_expected   = 8\n   too_many_parameters     = 9\n   illegal_command      = 10\n   wrong_asynchronous_parameters = 11\n   cant_enq_tbtco_entry    = 12\n   jobcount_generation_error  = 13\n   OTHERS      = 14.", after_en: "REPORT ZFVORGE_TESTCASE_247_FIXED.\n\nDATA request TYPE REF TO if_http_request.\nDATA lv_exec TYPE i.\nDATA: CMD       TYPE STRING,\n      LV_STATUS LIKE  EXTCMDEXEX-STATUS,\n      LV_EXIT   LIKE  EXTCMDEXEX-EXITCODE.\ncmd  = request->get_form_field( 'user_input' ).\n* Default: don't execute the command\nlv_exec = 0.\n* Check input with white list\nCASE cmd.\n  WHEN 'DIR'.\nlv_exec = 1.\n  WHEN 'LIST'.\nlv_exec = 1.\nENDCASE.\n* Only execute, if white list accepted the input\nIF lv_exec = 1.\n  CALL FUNCTION 'SXPG_CALL_SYSTEM'\n   EXPORTING\n  commandname    =  cmd\n  additional_parameters   = ''\n   IMPORTING\n  status      = lv_status\n  exitcode       = lv_exit\n   EXCEPTIONS\n  no_permission     = 0\n  command_not_found    = 1\n  parameters_too_long  = 2\n  security_risk     = 3\n  wrong_check_call_interface = 4\n  program_start_error  = 5\n  program_termination_error  = 6\n  x_error     = 7\n  parameter_expected   = 8\n  too_many_parameters  = 9\n  illegal_command   = 10\n  OTHERS      = 11.\nENDIF.", before_de: nil, after_de: nil, vf_case_id: 2, created_by_id: 1, is_approved: true, footnote_en: "\n<p><span>The Transactions SM49 and SM69 allow excellent control, which operating system commands should be available to an ABAP application. However, users should not be allowed to choose which of the maintained operating system command to execute.</span></p>\n\n<p><span>The primary recommendation is therefore to&nbsp;&nbsp;never feed any input to SXPG_CALL_SYSTEM and SXPG_COMMAND_EXECUTE .</span></p>\n\n<p><span>If there are important business reasons to do so, all input must be filtered by a&nbsp;&nbsp;white list&nbsp;&nbsp;(a list of allowed options) and this behavior must be documented. The white list validation functions of class cl_abap_dyn_prg should be used.</span></p>\n\n<p><span>The solution to code example (2) would be analogous.</span></p>\n\n<p><span>Please note that this is just example code and that this code is not applicable as a general blueprint to mitigate such problems.</span></p>\n", footnote_de: nil},
  {before_en: "REPORT ZFVORGE_TESTCASE_258.\n\nAUTHORITY-CHECK OBJECT 'S_DEVELOP'\n  ID 'DEVCLASS' FIELD 'ZPROGS'\n  ID 'OBJTYPE' FIELD 'FUNC'\n  ID 'OBJNAME' FIELD 'ZFT'\n  ID 'ACTVT' FIELD '02'.\nIF sy-subrc = 0.\n* Action authorized\nENDIF.", after_en: "REPORT ZFVORGE_TESTCASE_258_FIXED.\n\nAUTHORITY-CHECK OBJECT 'S_DEVELOP'\n  ID 'DEVCLASS' FIELD 'ZPROGS'\n  ID 'OBJTYPE' FIELD 'FUNC'\n  ID 'OBJNAME' FIELD 'ZFT'\n  ID 'P_GROUP' DUMMY \" Not required for type 'FUNC'\n  ID 'ACTVT' FIELD '02'.\nIF sy-subrc = 0.\n* Action authorized\nENDIF.", before_de: nil, after_de: nil, vf_case_id: 3, created_by_id: 1, is_approved: true, footnote_en: "\n<p>When an AUTHORITY-CHECK is performed, all IDs of the corresponding authorization object should be checked. If a certain ID is not required for the specific check, this decision should be made explicit by declaring the ID as DUMMY. If an ID is missing, this could be a mistake. If it is declared as DUMMY (ideally with proper documentation), reviewers know that the ID was ignored intentionally and for a reason. Therefore it&#39;s good practice to always cover all IDs of the corresponding authorization object.</p>\n", footnote_de: nil},
  {before_en: "REPORT ZFVORGE_TESTCASE_226.\n\nDATA errno(10)   TYPE c.\nDATA errmsg(128) TYPE c.\nPARAMETERS tmpdir(80) TYPE c.\nCALL 'C_REMOVE' ID 'FILE'   FIELD tmpdir\n                ID 'GROUP'  FIELD 'TMP'\n                ID 'ERRNO'  FIELD errno\n                ID 'ERRMSG' FIELD errmsg.", after_en: "REPORT ZFVORGE_TESTCASE_226.\n\nDATA errno(10)   TYPE c.\nDATA errmsg(128) TYPE c.\nPARAMETERS tmpdir(80) TYPE c.\nCALL 'C_REMOVE' ID 'FILE'   FIELD tmpdir\n                ID 'GROUP'  FIELD 'TMP'\n                ID 'ERRNO'  FIELD errno\n                ID 'ERRMSG' FIELD errmsg.", before_de: nil, after_de: nil, vf_case_id: 4, created_by_id: 1, is_approved: true, footnote_en: "\n<p><span>Do not use this kernel function, as it can cause significant damage to the integrity of an SAP system. Use the ABAP command DELETE DATASET in order to delete files. Do not delete audit files.</span></p>\n\n<p><span>Solution example is not applicable.</span></p>\n", footnote_de: nil},
  {before_en: "REPORT ZFVORGE_TESTCASE_142.\n\nDATA request TYPE REF TO if_http_request.\nDATA lv_carr TYPE string.\nDATA lv_stmt(400) TYPE c.\nDATA lv_len TYPE i.\nlv_carr  = request->get_form_field( 'carrier' ).\nCONCATENATE `UPDATE \"ZVF_FLIGHTS\" SET carrid = '102'`\n   `WHERE carrname = '`\n    lv_carr\n   `'`\n   INTO  lv_stmt\n   SEPARATED BY space.\nlv_len = strlen( lv_stmt ).\nCALL 'C_DB_EXECUTE'\n  ID 'STATLEN' FIELD lv_len\n  ID 'STATTXT' FIELD lv_stmt\n  ID 'ROWNUM'  FIELD lv_row\n  ID 'SQLERR'  FIELD l_sql_error\n  ID 'ERRTXT'  FIELD l_sql_errtxt.", after_en: "REPORT ZFVORGE_TESTCASE_142.\n\nDATA request TYPE REF TO if_http_request.\nDATA lv_carr TYPE string.\nDATA lv_stmt(400) TYPE c.\nDATA lv_len TYPE i.\nlv_carr  = request->get_form_field( 'carrier' ).\nCONCATENATE `UPDATE \"ZVF_FLIGHTS\" SET carrid = '102'`\n   `WHERE carrname = '`\n    lv_carr\n   `'`\n   INTO  lv_stmt\n   SEPARATED BY space.\nlv_len = strlen( lv_stmt ).\nCALL 'C_DB_EXECUTE'\n  ID 'STATLEN' FIELD lv_len\n  ID 'STATTXT' FIELD lv_stmt\n  ID 'ROWNUM'  FIELD lv_row\n  ID 'SQLERR'  FIELD l_sql_error\n  ID 'ERRTXT'  FIELD l_sql_errtxt.", before_de: nil, after_de: nil, vf_case_id: 5, created_by_id: 1, is_approved: true, footnote_en: "\n<p>If parameter&nbsp;&nbsp;lv_carr&nbsp;&nbsp;contains malicious SQL commands, the above SQL syntax can be modified.</p>\n\n<p>If a malicious user enters a sequence like&nbsp;&nbsp;&#39; OR &#39;1&#39;=&#39;1&nbsp;&nbsp;the WHERE condition will be as follows:</p>\n\n<p>carrname = &#39; &#39; OR &#39;1&#39;=&#39;1 &#39;</p>\n\n<p>This will always match, changing all entries in that table.</p>\n\n<p>As a result, this database statement can be used to modify arbitrary database entries without authorization.</p>\n\n<p>Only use Open SQL in order to access the SAP database. If you use kernel functions, you bypass important security mechanisms of Open SQL and thus put your company&#39;s data at risk. Don&#39;t use this kernel function.</p>\n\n<p>Solution example is not applicable.</p>\n", footnote_de: nil}
])
